دانا افاضلی - ۹۸۱۰۵۵۹۲

محمدمهدی فرهادی - ۹۹۱۰۵۶۳۴

# بخش اول – پیاده‌سازی الگوی Adapter

## زیر بخش ۱: انتخاب نوع Adapter

در الگوی Adapter، دو شیوه اصلی برای پیاده‌سازی وجود دارد: یکی بر پایه ارث‌بری (Class Scope) و دیگری بر پایه ترکیب (Object Scope). در زبان جاوا به دلیل اینکه امکان چندارثی برای کلاس‌ها وجود ندارد، عملاً نمی‌توانیم همزمان یک کلاس را از کلاس کتابخانه (مثلاً گراف JGraphT) و یک واسط خودمان ارث‌بری کنیم. بنابراین، راه‌حل منطقی و مرسوم، همان **Object Adapter** یا شیء‌محور است.

در این روش، ما یک واسط به نام `Graph<T>` تعریف کردیم که متدهای اصلی کار با گراف را دارد. بعد، کلاس آداپتر (`JGraphTAdapter`) را طوری ساختیم که یک شیء از کلاس گراف JGraphT را به صورت فیلد داخلی نگه می‌دارد و هر متدی که از واسط صدا زده می‌شود، درخواست را به متد متناظر در شیء JGraphT منتقل می‌کند.  
به این ترتیب، بقیه کدها (مثل BFS یا DFS) فقط و فقط با همین واسط کار می‌کنند و کاملاً از جزییات و وابستگی به JGraphT بی‌خبر هستند.  
دلیل اصلی این انتخاب، علاوه بر محدودیت فنی جاوا، این است که اگر روزی تصمیم گرفتیم کتابخانه گراف را عوض کنیم، فقط کافیست یک آداپتر جدید بنویسیم و دیگر لازم نیست هیچ‌کدام از الگوریتم‌های پیمایش یا کدهای کلاینت را دست بزنیم. این کار نگهداری پروژه را بسیار راحت‌تر و آینده‌نگرانه‌تر می‌کند.

## زیر بخش ۲: نحوه پیاده‌سازی الگو

برای اجرای این الگو، ابتدا واسط `Graph<T>` را طراحی کردیم تا متدهای پایه مثل افزودن رأس و یال، گرفتن همسایه‌ها و غیره را شامل شود.  
در قدم بعدی، کلاس `JGraphTAdapter` را ساختیم که این واسط را پیاده‌سازی می‌کند و پشت صحنه، با یک شیء گراف از JGraphT کار می‌کند. تمام متدهای واسط، به متدهای معادل در این شیء ارجاع داده می‌شوند و هیچ چیز اضافی از کتابخانه JGraphT به بیرون منتقل نمی‌شود.

در نهایت، الگوریتم‌های پیمایش (BFS و DFS) طوری نوشته شدند که فقط به واسط `Graph<T>` وابسته باشند. به این معنا که الگوریتم‌ها کاملاً مستقل از نوع پیاده‌سازی گراف هستند و اگر بعدها تصمیم به تعویض کتابخانه گراف داشته باشیم، نیازی به تغییر در این کدها نیست.  
این ساختار باعث افزایش انعطاف‌پذیری و مقیاس‌پذیری پروژه می‌شود و کدها را به‌مراتب خواناتر و قابل نگهداری‌تر می‌کند.

ساختار کد به شکل زیر میباشد:
```
01-Adapter-Implementation
├── pom.xml
└── src
    ├── main
    │   └── java
    │       ├── adapter
    │       │   └── jgrapht
    │       │       └── JGraphTAdapter.java
    │       ├── app
    │       │   └── Main.java
    │       ├── graph
    │       │   └── Graph.java
    │       └── traversal
    │           ├── BFS.java
    │           └── DFS.java
    └── test
        └── java
            └── traversal
                └── BFSTest.java
```

- **pom.xml**  
  فایل تنظیمات پروژه Maven، شامل تعریف وابستگی‌ها (مانند JGraphT)، نسخه جاوا و تنظیمات اجرای برنامه اصلی.

- **src/main/java/adapter/jgrapht/JGraphTAdapter.java**  
  پیاده‌سازی آداپتر شیءمحور که واسط `Graph<T>` را با استفاده از گراف JGraphT پیاده می‌کند و تمام متدها را به این کتابخانه فوروارد می‌کند.

- **src/main/java/app/Main.java**  
  کلاس راه‌انداز (driver) که با ساختن یک گراف نمونه، الگوریتم‌های BFS و DFS را اجرا و نتیجه را در خروجی چاپ می‌کند.

- **src/main/java/graph/Graph.java**  
  واسط (interface) عمومی گراف که متدهای اصلی لازم برای تراورس را به شکل انتزاعی تعریف می‌کند و ارتباط کلاینت را از کتابخانه گراف جدا می‌کند.

- **src/main/java/traversal/BFS.java**  
  پیاده‌سازی الگوریتم جستجوی سطح‌به‌سطح (BFS) که فقط به واسط `Graph<T>` وابسته است و ترتیب پیمایش را برمی‌گرداند.

- **src/main/java/traversal/DFS.java**  
  پیاده‌سازی الگوریتم جستجوی عمقی (DFS) که بر اساس واسط `Graph<T>` عمل می‌کند و ترتیب پیمایش عمقی را ارائه می‌دهد.

- **src/test/java/traversal/BFSTest.java** (اختیاری)  
  یک تست ساده با استفاده از JUnit که درستی عملکرد الگوریتم BFS را روی یک گراف کوچک بررسی می‌کند.




# بخش سوم - تحلیل استفاده از الگوی Strategy در پروژه

### چرا از الگوی Strategy استفاده شده است؟

در این پروژه لازم بود که گراف را بتوانیم با دو الگوریتم مختلف (BFS و DFS) پیمایش کنیم و در عین حال ساختار کد انعطاف‌پذیر و قابل توسعه باقی بماند. با استفاده از الگوی Strategy و تعریف اینترفیس `Traverser`، این امکان فراهم شد که هر الگوریتم پیمایش در یک کلاس مستقل پیاده‌سازی شود و فقط با تعویض شیء Traverser، منطق پیمایش را عوض کنیم. این کار باعث شد تغییر یا اضافه‌کردن الگوریتم‌های جدید بدون دست زدن به سایر بخش‌های کد ممکن باشد.

### توضیح مختصر از نحوه پیاده‌سازی

واسط `Traverser` متد اصلی پیمایش (مثلاً `traverse`) را تعریف می‌کند. هر الگوریتم پیمایش (BFS یا DFS) در یک کلاس جداگانه (`BFSGraphTraverser` یا `DFSGraphTraverser`) اینترفیس Traverser را پیاده‌سازی کرده و منطق مخصوص به خودش را دارد. موقع اجرای برنامه، کافی است شیء مورد نظر از نوع Traverser را به گراف بدهیم تا پیمایش با الگوریتم مورد نظر انجام شود. این ساختار، نگهداری و توسعه پروژه را بسیار ساده‌تر و شفاف‌تر می‌کند.
