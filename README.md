دانا افاضلی - ۹۸۱۰۵۵۹۲

محمدمهدی فرهادی - ۹۹۱۰۵۶۳۴

# بخش اول – پیاده‌سازی الگوی Adapter

## زیر بخش ۱: انتخاب نوع Adapter

در الگوی Adapter، دو شیوه اصلی برای پیاده‌سازی وجود دارد: یکی بر پایه ارث‌بری (Class Scope) و دیگری بر پایه ترکیب (Object Scope). در زبان جاوا به دلیل اینکه امکان چندارثی برای کلاس‌ها وجود ندارد، عملاً نمی‌توانیم همزمان یک کلاس را از کلاس کتابخانه (مثلاً گراف JGraphT) و یک واسط خودمان ارث‌بری کنیم. بنابراین، راه‌حل منطقی و مرسوم، همان **Object Adapter** یا شیء‌محور است.

در این روش، ما یک واسط به نام `Graph<T>` تعریف کردیم که متدهای اصلی کار با گراف را دارد. بعد، کلاس آداپتر (`JGraphTAdapter`) را طوری ساختیم که یک شیء از کلاس گراف JGraphT را به صورت فیلد داخلی نگه می‌دارد و هر متدی که از واسط صدا زده می‌شود، درخواست را به متد متناظر در شیء JGraphT منتقل می‌کند.  
به این ترتیب، بقیه کدها (مثل BFS یا DFS) فقط و فقط با همین واسط کار می‌کنند و کاملاً از جزییات و وابستگی به JGraphT بی‌خبر هستند.  
دلیل اصلی این انتخاب، علاوه بر محدودیت فنی جاوا، این است که اگر روزی تصمیم گرفتیم کتابخانه گراف را عوض کنیم، فقط کافیست یک آداپتر جدید بنویسیم و دیگر لازم نیست هیچ‌کدام از الگوریتم‌های پیمایش یا کدهای کلاینت را دست بزنیم. این کار نگهداری پروژه را بسیار راحت‌تر و آینده‌نگرانه‌تر می‌کند.

## زیر بخش ۲: نحوه پیاده‌سازی الگو

برای اجرای این الگو، ابتدا واسط `Graph<T>` را طراحی کردیم تا متدهای پایه مثل افزودن رأس و یال، گرفتن همسایه‌ها و غیره را شامل شود.  
در قدم بعدی، کلاس `JGraphTAdapter` را ساختیم که این واسط را پیاده‌سازی می‌کند و پشت صحنه، با یک شیء گراف از JGraphT کار می‌کند. تمام متدهای واسط، به متدهای معادل در این شیء ارجاع داده می‌شوند و هیچ چیز اضافی از کتابخانه JGraphT به بیرون منتقل نمی‌شود.

در نهایت، الگوریتم‌های پیمایش (BFS و DFS) طوری نوشته شدند که فقط به واسط `Graph<T>` وابسته باشند. به این معنا که الگوریتم‌ها کاملاً مستقل از نوع پیاده‌سازی گراف هستند و اگر بعدها تصمیم به تعویض کتابخانه گراف داشته باشیم، نیازی به تغییر در این کدها نیست.  
این ساختار باعث افزایش انعطاف‌پذیری و مقیاس‌پذیری پروژه می‌شود و کدها را به‌مراتب خواناتر و قابل نگهداری‌تر می‌کند.

ساختار کد به شکل زیر میباشد:
```
01-Adapter-Implementation
├── pom.xml
└── src
    ├── main
    │   └── java
    │       ├── adapter
    │       │   └── jgrapht
    │       │       └── JGraphTAdapter.java
    │       ├── app
    │       │   └── Main.java
    │       ├── graph
    │       │   └── Graph.java
    │       └── traversal
    │           ├── BFS.java
    │           └── DFS.java
    └── test
        └── java
            └── traversal
                └── BFSTest.java
```

- **pom.xml**  
  فایل تنظیمات پروژه Maven، شامل تعریف وابستگی‌ها (مانند JGraphT)، نسخه جاوا و تنظیمات اجرای برنامه اصلی.

- **src/main/java/adapter/jgrapht/JGraphTAdapter.java**  
  پیاده‌سازی آداپتر شیءمحور که واسط `Graph<T>` را با استفاده از گراف JGraphT پیاده می‌کند و تمام متدها را به این کتابخانه فوروارد می‌کند.

- **src/main/java/app/Main.java**  
  کلاس راه‌انداز (driver) که با ساختن یک گراف نمونه، الگوریتم‌های BFS و DFS را اجرا و نتیجه را در خروجی چاپ می‌کند.

- **src/main/java/graph/Graph.java**  
  واسط (interface) عمومی گراف که متدهای اصلی لازم برای تراورس را به شکل انتزاعی تعریف می‌کند و ارتباط کلاینت را از کتابخانه گراف جدا می‌کند.

- **src/main/java/traversal/BFS.java**  
  پیاده‌سازی الگوریتم جستجوی سطح‌به‌سطح (BFS) که فقط به واسط `Graph<T>` وابسته است و ترتیب پیمایش را برمی‌گرداند.

- **src/main/java/traversal/DFS.java**  
  پیاده‌سازی الگوریتم جستجوی عمقی (DFS) که بر اساس واسط `Graph<T>` عمل می‌کند و ترتیب پیمایش عمقی را ارائه می‌دهد.

- **src/test/java/traversal/BFSTest.java** (اختیاری)  
  یک تست ساده با استفاده از JUnit که درستی عملکرد الگوریتم BFS را روی یک گراف کوچک بررسی می‌کند.


بخش دوم – تغییر کتابخانه
در این بخش، فرآیند جایگزینی کتابخانه JUNG با JGraphT و تأثیرات آن بر روی پروژه با استفاده از الگوی طراحی Adapter تشریح می‌شود.

زیر بخش ۱: گزارشی از چگونگی تغییر کتابخانه
فرآیند تغییر کتابخانه به لطف استفاده از الگوی Adapter بسیار ساده و کنترل‌شده بود. هدف اصلی این بود که کد‌های اصلی برنامه، یعنی الگوریتم‌های پیمایش (BFS و DFS) و کلاس راه‌انداز (Main)، هیچ تغییری نکنند. این هدف با طی کردن مراحل زیر محقق شد:

۱. حفظ واسط Graph<T>: واسط Graph<T> که در بخش اول طراحی شد، به عنوان یک قرارداد ثابت باقی ماند. این واسط، نقطه اتصال اصلی بین کدهای کلاینت (الگوریتم‌های پیمایش) و پیاده‌سازی گراف است و تضمین می‌کند که کلاینت‌ها از جزئیات کتابخانه زیرین بی‌خبر بمانند.

۲. ایجاد آداپتر جدید: یک کلاس جدید به نام JGraphTAdapter ساخته شد که واسط Graph<T> را پیاده‌سازی می‌کند. این کلاس یک شیء از گراف کتابخانه JGraphT (یعنی DefaultDirectedGraph) را در داخل خود نگه می‌دارد و تمام درخواست‌هایی که از طریق متدهای واسط Graph<T> دریافت می‌کند را به متدهای معادل در شیء گراف JGraphT ترجمه و ارسال می‌کند. برای مثال، فراخوانی متد addEdge در آداپتر، منجر به فراخوانی متد addEdge در شیء JGraphT می‌شود.

۳. جایگزینی در کلاینت: تنها تغییری که در کد کلاینت (کلاس app.Main) لازم بود، تغییر در خط مربوط به ساختن شیء گراف بود. به جای استفاده از آداپتر قبلی (که برای JUNG بود)، شیء گراف با استفاده از آداپتر جدید ساخته شد:

Graph<Integer> graph = new JGraphTAdapter<>();

با همین یک خط تغییر، کل منطق زیربنایی گراف بدون نیاز به تغییر در سایر بخش‌های برنامه، عوض شد.

۴. به‌روزرسانی وابستگی‌ها: در فایل pom.xml، وابستگی مربوط به کتابخانه JGraphT اضافه گردید و وابستگی کتابخانه قبلی (JUNG) حذف شد تا پروژه به طور کامل به کتابخانه جدید مهاجرت کند.

این فرآیند به وضوح نشان می‌دهد که چگونه الگوی Adapter با ایجاد یک لایه انتزاعی، وابستگی شدید به یک کتابخانه خاص را از بین می‌برد و انعطاف‌پذیری سیستم را برای تغییرات آینده به شدت افزایش می‌دهد.

زیر بخش ۲: تغییرات ناشی از تغییر کتابخانه از JUNG به JGraphT
به لطف طراحی صحیح و استفاده از الگوی Adapter، تغییرات در پروژه بسیار محدود و متمرکز بودند. در ادامه، لیست کامل تغییرات ارائه شده است:

فایل‌های بدون تغییر (Unchanged Files):

graph/Graph.java: این واسط به عنوان قرارداد اصلی، ثابت باقی ماند.

traversal/BFS.java: این کلاس چون تنها به واسط Graph<T> وابسته بود، هیچ تغییری نکرد.

traversal/DFS.java: این کلاس نیز مانند BFS، بدون هیچ تغییری به کار خود ادامه داد.

فایل‌های جدید (New Files):

adapter/jgrapht/JGraphTAdapter.java: این فایل قلب اصلی تغییرات است. این کلاس جدید به عنوان آداپتر برای کتابخانه JGraphT عمل می‌کند و منطق ترجمه درخواست‌ها از واسط Graph به JGraphT را پیاده‌سازی می‌کند.

فایل‌های تغییریافته (Modified Files):

app/Main.java: تنها یک خط از این فایل تغییر کرد و آن هم خط مربوط به ساختن نمونه از گراف بود که به جای آداپتر قبلی، از JGraphTAdapter استفاده کرد.

pom.xml: فایل تنظیمات Maven برای حذف وابستگی JUNG و افزودن وابستگی jgrapht-core ویرایش شد.

همانطور که مشاهده می‌شود، الگوی Adapter موفق شد "موج تغییرات" ناشی از تعویض یک جزء اساسی (کتابخانه گراف) را مهار کرده و آن را تنها به یک کلاس آداپتر و یک خط کد در کلاینت محدود کند. این موضوع، ارزش و قدرت این الگو در نگهداری و توسعه نرم‌افزار را به خوبی نشان می‌دهد.




# بخش سوم - تحلیل استفاده از الگوی Strategy در پروژه

### چرا از الگوی Strategy استفاده شده است؟

در این پروژه لازم بود که گراف را بتوانیم با دو الگوریتم مختلف (BFS و DFS) پیمایش کنیم و در عین حال ساختار کد انعطاف‌پذیر و قابل توسعه باقی بماند. با استفاده از الگوی Strategy و تعریف اینترفیس `Traverser`، این امکان فراهم شد که هر الگوریتم پیمایش در یک کلاس مستقل پیاده‌سازی شود و فقط با تعویض شیء Traverser، منطق پیمایش را عوض کنیم. این کار باعث شد تغییر یا اضافه‌کردن الگوریتم‌های جدید بدون دست زدن به سایر بخش‌های کد ممکن باشد.

### توضیح مختصر از نحوه پیاده‌سازی

واسط `Traverser` متد اصلی پیمایش (مثلاً `traverse`) را تعریف می‌کند. هر الگوریتم پیمایش (BFS یا DFS) در یک کلاس جداگانه (`BFSGraphTraverser` یا `DFSGraphTraverser`) اینترفیس Traverser را پیاده‌سازی کرده و منطق مخصوص به خودش را دارد. موقع اجرای برنامه، کافی است شیء مورد نظر از نوع Traverser را به گراف بدهیم تا پیمایش با الگوریتم مورد نظر انجام شود. این ساختار، نگهداری و توسعه پروژه را بسیار ساده‌تر و شفاف‌تر می‌کند.
